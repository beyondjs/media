/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@beyond-js/media/base';
// adapters\node\fs-adapter.ts
declare namespace ns_0 {
  import IFileAdapter = ns_3.IFileAdapter;
  import IFile = ns_4.IFile;
  import IReadOptions = ns_4.IReadOptions;
  import IWriteOptions = ns_4.IWriteOptions;
  import IStreamOptions = ns_4.IStreamOptions;
  export class FsAdapter implements IFileAdapter {
    environment: string;
    supports(): boolean;
    read(file: IFile, opts?: IReadOptions): Promise<Uint8Array>;
    write(file: IFile, data: Uint8Array, opts?: IWriteOptions): Promise<void>;
    stream(file: IFile, opts?: IStreamOptions): AsyncIterable<Uint8Array>;
    close(): Promise<void>;
  }
}


// errors.ts
declare namespace ns_1 {
  /**
   * Custom error for file operations
   */
  export class FileError extends Error {
    constructor(message: string);
  }
}


// file.ts
declare namespace ns_2 {
  /**
   * Core File implementation
   */
  import IFile = ns_4.IFile;
  import IReadOptions = ns_4.IReadOptions;
  import IWriteOptions = ns_4.IWriteOptions;
  import IStreamOptions = ns_4.IStreamOptions;
  import IFileMeta = __beyond_dep_ns_0.IFileMeta;
  import FileBase = __beyond_dep_ns_0.FileBase;
  import IFileAdapter = ns_3.IFileAdapter;
  export class File extends FileBase implements IFile {
    meta: IFileMeta;
    private static adapters;
    private adapter;
    /**
     * @param meta Metadata del archivo
     * @param environment Entorno a usar (por defecto: 'node')
     */
    constructor(meta: IFileMeta, environment?: string);
    static registerAdapter(a: IFileAdapter): void;
    read(opts?: IReadOptions): Promise<Uint8Array>;
    write(d: Uint8Array, opts?: IWriteOptions): Promise<void>;
    stream(opts?: IStreamOptions): AsyncIterable<Uint8Array>;
    close(): Promise<void>;
    updateMetaSize(size: number): void;
  }
}


// types\adapter-interfaces.ts
declare namespace ns_3 {
  import IFile = ns_4.IFile;
  import IReadOptions = ns_4.IReadOptions;
  import IWriteOptions = ns_4.IWriteOptions;
  import IStreamOptions = ns_4.IStreamOptions;
  /**
   * File adapter interface abstraction
   */
  export interface IFileAdapter {
    /**
     * Nombre del entorno soportado por el adapter (por ejemplo: 'node', 'browser', etc)
     */
    environment: string;
    supports(file: IFile): boolean;
    read(file: IFile, opts?: IReadOptions): Promise<Uint8Array>;
    write(file: IFile, data: Uint8Array, opts?: IWriteOptions): Promise<void>;
    stream(file: IFile, opts?: IStreamOptions): AsyncIterable<Uint8Array>;
    close(file: IFile): Promise<void>;
  }
}


// types\file-interfaces.ts
declare namespace ns_4 {
  import IFileMeta = __beyond_dep_ns_0.IFileMeta;
  /**
   * Options for reading a file
   *
   */
  export interface IReadOptions {
    offset?: number;
    length?: number;
  }
  /**
   * Options for writing to a file
   */
  export interface IWriteOptions {
    offset?: number;
  }
  /**
   * Options for streaming a file
   */
  export interface IStreamOptions {
    chunk_size?: number;
  }
  /**
   * File interface abstraction
   */
  export interface IFile {
    meta: IFileMeta;
    read(opts?: IReadOptions): Promise<Uint8Array>;
    write(data: Uint8Array, opts?: IWriteOptions): Promise<void>;
    stream(opts?: IStreamOptions): AsyncIterable<Uint8Array>;
    close(): Promise<void>;
  }
}


// types\parser-interfaces.ts
declare namespace ns_5 {
  /**
   * Parser interface for generic file parsing
   */
  import IFile = ns_4.IFile;
  /**
   * Parser interface for generic file parsing
   */
  export interface IParser<T> {
    canHandle(file: IFile): boolean;
    parse(file: IFile): Promise<T>;
  }
}


export import FsAdapter = ns_0.FsAdapter;
export import FileError = ns_1.FileError;
export import File = ns_2.File;
export import IFileAdapter = ns_3.IFileAdapter;
export import IReadOptions = ns_4.IReadOptions;
export import IWriteOptions = ns_4.IWriteOptions;
export import IStreamOptions = ns_4.IStreamOptions;
export import IFile = ns_4.IFile;
export import IParser = ns_5.IParser;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };